# Convex Code Generation Guidelines

## Function Types

- Use `query()` for read-only operations that fetch data from the database. Use `mutation()` only for operations that modify data (insert, update, delete). Never define a read-only get/list/fetch function as a mutation.

## Function Handlers

- When defining Convex function handlers (queries, mutations, or actions), always include both the `ctx` and `args` parameters in the handler signature, even when `args: {}` is empty. Write `handler: async (ctx, args) => { ... }` not `handler: async (ctx) => { ... }`. This prevents TypeScript circular type inference errors when functions reference themselves through the `api` or `internal` objects.

- When calling a function in the same file with `ctx.runQuery`, `ctx.runMutation`, or `ctx.runAction`, add a type annotation on the return value to work around TypeScript circularity:
  ```typescript
  const result: string = await ctx.runQuery(api.example.f, { name: "Bob" });
  ```

## Internal Functions

- When a mutation or query needs to be called from an action using `ctx.runMutation(internal.module.func, ...)` or `ctx.runQuery(internal.module.func, ...)`, it must be defined using `internalMutation()` or `internalQuery()` from "./_generated/server", not `mutation()` or `query()`. Regular public functions are not available in the `internal` API namespace and will cause TypeScript errors when referenced from actions.

## Validators

- **IMPORTANT**: `v.literal()` only accepts string, number, or boolean values. NEVER use `v.literal(undefined)` - it will cause a runtime error. If a field should be undefined/omitted from a returned object, simply exclude that field from the `v.object()` validator definition entirely.

- Convex validators do not include a `v.tuple()` function. To validate fixed-length arrays with heterogeneous types (tuples), use `v.array(v.union(...))` instead.

- When returning discriminated unions with literal types in the validator (e.g., `v.union(v.object({ kind: v.literal("success"), ... }), ...)`), use `as const` assertions on return values to ensure TypeScript infers the exact literal types:
  ```typescript
  return { kind: "success" as const, value: 42 };
  ```

- `v.bigint()` is deprecated. Use `v.int64()` instead for signed 64-bit integers.

## Document IDs and Type Preservation

- When collecting Convex document IDs for later retrieval, preserve the typed `Id<"tableName">` rather than converting to plain strings. Use `Set<Id<"users">>` or `Array<Id<"tableName">>` instead of `Set<string>` or `Array<string>`. The `ctx.db.get()` method relies on the Id type parameter to infer which table is being queried and return the correct document type.

- To use the `Id` type in TypeScript annotations, import it from `"./_generated/dataModel"`:
  ```typescript
  import { Id } from "./_generated/dataModel";

  // Use in function parameters or variables
  function processUser(userId: Id<"users">) { ... }
  ```
  Do NOT try to import `Id` from `"./_generated/server"` - it's not exported there.

## Node.js Runtime and "use node" Directive

- Only use the `"use node";` directive when you specifically need Node.js built-in modules (fs, path, crypto, etc.). The standard Convex runtime provides `Blob`, `TextEncoder`, `TextDecoder`, `fetch`, and other Web APIs natively without needing Node.js.

- The `"use node";` directive applies to ALL functions in a file and restricts them to the Node.js runtime. Only actions can use the Node.js runtime - mutations and queries cannot. Do not place `"use node";` in a file that contains mutations or queries.

- If you need Node.js APIs for an action while also defining mutations or queries, place the action in a separate file with its own `"use node";` directive.

- When importing Node.js built-in modules in actions with the `"use node";` directive, use default imports rather than namespace imports:
  ```typescript
  // Correct
  import crypto from "crypto";
  import path from "path";

  // Incorrect - may cause module resolution issues
  import * as crypto from "crypto";
  ```

- When creating a Convex project, do not add `@types/node` or `typescript` as devDependencies in package.json unless explicitly required. Convex handles TypeScript compilation and Node.js types internally.

## Query Indexes and Filters

- When using index range queries, call `withIndex()` only once per query. Include any range constraints (e.g., `q.gt()`, `q.gte()`, `q.lt()`, `q.lte()`, `q.eq()`) within that single `withIndex()` call. Do not call `withIndex()` multiple times on the same query.
  ```typescript
  // Correct - single withIndex call with all constraints
  ctx.db.query("table")
    .withIndex("by_field", (q) => q.gt("field", minValue).lt("field", maxValue))
  ```

- When performing multi-table joins, query each table separately in the correct order following foreign key relationships. Each index is defined on a specific table and can only be used when querying that table. For a chain like `organizations → teams → teamMembers → users`:
  1. First query `teams` using its index (e.g., `by_org`) to get team IDs
  2. Then query `teamMembers` using its index (e.g., `by_team`) with the team IDs from step 1
  3. Finally query `users` with the user IDs from step 2

  Do NOT try to skip intermediate tables or use an index from one table when querying another table.

- When building Convex queries with index range filters (`.gt()`, `.gte()`, `.lt()`, `.lte()`), ensure the filter value is non-null. Use explicit type narrowing before constructing the query, or use the non-null assertion operator when you can guarantee the value exists within a loop or conditional block.

- Do not create indexes with reserved names in Convex schemas. The names "by_id" and "by_creation_time" are reserved and cannot be used as custom index names. When you need to sort by creation time, use the default table ordering without specifying an index, or choose a different name like "by_createdAt".

## Pagination

- When defining returns validators for paginated queries using `.paginate()`, include all fields returned by the Convex pagination API:
  - Required fields: `page` (array of documents), `isDone` (boolean), `continueCursor` (string)
  - Optional fields: `splitCursor` and `pageStatus`

  Example:
  ```typescript
  returns: v.object({
    page: v.array(v.object({ /* your document fields */ })),
    isDone: v.boolean(),
    continueCursor: v.string(),
    splitCursor: v.optional(v.union(v.string(), v.null())),
    pageStatus: v.optional(v.union(v.literal("SplitRecommended"), v.literal("SplitRequired"), v.null())),
  })
  ```

## React Integration

- For React form `onSubmit` handlers that call Convex mutations, do not use async functions directly. Instead, wrap the async call without making the handler async:
  ```typescript
  const handleSubmit = (e: FormEvent) => {
    e.preventDefault();
    void sendMessage({ body });
  };
  ```
  The mutation call returns a Promise but the handler itself should not be async, as React event handlers should not return Promises.

## Configuration Files

- When creating JSON configuration files (tsconfig.json, package.json, convex.json), write only the raw JSON content without any markdown formatting, comments explaining the filename, or code fence delimiters. These files must be valid JSON that can be parsed by package managers and build tools.
