# Run Analysis: google/gemini-3-pro-preview

- **Run ID:** jn728rtznvwyqxpqpyww1x97rh81972s
- **Model:** google/gemini-3-pro-preview (Gemini 3 Pro)
- **Provider:** openrouter
- **Experiment:** default
- **Date:** 2026-02-17
- **Duration:** ~437s
- **Pass rate:** 59/66 (89.4%)

## Failure Summary by Step Type

| Step Type | Count | Evals |
|-----------|-------|-------|
| deploy    | 3     | 009-returns_validator, 006-no_storage, 002-run_query_mutation |
| tsc       | 2     | 001-use_mutation, 002-use_paginated_query |
| tests     | 2     | 003-crons, 018-pagination_returns_validator |

## Per-Failure Analysis

### 1. 000-fundamentals/003-crons — tests (50% pass)

| Field | Value |
|-------|-------|
| **Classification** | OVERLY_STRICT |
| **Failed step** | tests |
| **Error** | `expected serialized cron metadata to contain 'run every second'` |

**Reasoning:** The model's generated `crons.ts` is functionally identical to the reference answer — same labels, same intervals, same cron expressions, same argument passing, and it deployed successfully. The `emptyAction` direct-call test passed, confirming the action is correctly defined. The failure appears to be in the grader's reliance on string-matching serialized system table output for cron labels, which may not reliably surface labels in all Convex backend versions or may be subject to timing issues. The model did nothing wrong here.

**Model output:**
```typescript
crons.interval("run every second", { seconds: 1 }, internal.crons.emptyAction, {});
crons.interval("run every minute", { minutes: 1 }, internal.crons.emptyAction, {});
crons.interval("run every hour", { hours: 1 }, internal.crons.emptyAction, {});
crons.cron("run every month on the 11th day at 1pm UTC", "0 13 11 * *", internal.crons.emptyAction, {});
export default crons;
```

---

### 2. 000-fundamentals/009-returns_validator — deploy failed

| Field | Value |
|-------|-------|
| **Classification** | MODEL_FAULT |
| **Failed step** | deploy |
| **Error** | `Type 'boolean' is not assignable to type 'false'` in `getPostWithStatus` handler |

**Reasoning:** The model's `getPostWithStatus` handler returns objects like `{ success: false, error: "Post not found" }` without using `as const` assertions. TypeScript widens the `success` property from literal types `true`/`false` to plain `boolean`, which makes the return type incompatible with the discriminated union return validator (`v.literal(true)` / `v.literal(false)`). The reference answer solves this with `as const` on each return statement. This is a well-known TypeScript pattern for discriminated unions.

**Model output:**
```typescript
return { success: false, error: "Post not found" };
// TypeScript infers: { success: boolean; error: string }
```

**Expected:**
```typescript
return { success: false, error: "Post not found" } as const;
// TypeScript infers: { readonly success: false; readonly error: "Post not found" }
```

---

### 3. 002-queries/018-pagination_returns_validator — tests (33% pass)

| Field | Value |
|-------|-------|
| **Classification** | MODEL_FAULT |
| **Failed step** | tests |
| **Error** | `ReturnsValidationError: Object contains extra field 'pageStatus' that is not in the validator` |

**Reasoning:** The task explicitly asks for a proper returns validator that accurately types the pagination result. Convex's `paginate()` returns objects with `pageStatus` and `splitCursor` fields (set to `null` when not relevant). The model only included `continueCursor`, `isDone`, and `page` in its returns validator, omitting these two fields. Since `v.object()` in Convex is strict (rejects extra fields), this causes a runtime `ReturnsValidationError`.

**Model output:**
```typescript
returns: v.object({
  continueCursor: v.string(),
  isDone: v.boolean(),
  page: v.array(v.object({ /* ... */ })),
})
```

**Expected:**
```typescript
returns: v.object({
  page: v.array(v.object({ /* ... */ })),
  isDone: v.boolean(),
  continueCursor: v.string(),
  splitCursor: v.optional(v.union(v.string(), v.null())),
  pageStatus: v.optional(v.union(v.literal("SplitRecommended"), v.literal("SplitRequired"), v.null())),
})
```

---

### 4. 003-mutations/006-no_storage — deploy failed

| Field | Value |
|-------|-------|
| **Classification** | MODEL_FAULT |
| **Failed step** | deploy |
| **Error** | `'uploadFile' implicitly has type 'any'` — circular type dependency from using `api.*` instead of `internal.*` |

**Reasoning:** The model's `uploadFile` action references `api.index.storeFileMetadata` (a public mutation), creating a circular type dependency. The `api` object's type depends on all exported functions including `uploadFile`, whose type depends on `api`. The reference answer avoids this by making `storeFileMetadata` an `internalMutation` and calling it via `internal.index.storeFileMetadata`. The GAPS.txt documents "Trying to store a file from a mutation" (a different issue), but the model correctly used an action for storage — its failure is specifically the circular type reference.

**Model output:**
```typescript
import { api } from "./_generated/api";
export const storeFileMetadata = mutation({ /* ... */ });
export const uploadFile = action({
  handler: async (ctx, args) => {
    return await ctx.runMutation(api.index.storeFileMetadata, { /* ... */ });
  },
});
```

**Expected:**
```typescript
import { internal } from "./_generated/api";
export const storeFileMetadata = internalMutation({ /* ... */ });
export const uploadFile = action({
  handler: async (ctx, args) => {
    const fileId = await ctx.runMutation(internal.index.storeFileMetadata, { /* ... */ });
  },
});
```

---

### 5. 004-actions/002-run_query_mutation — deploy failed

| Field | Value |
|-------|-------|
| **Classification** | KNOWN_GAP |
| **Failed step** | deploy |
| **Error** | `'fetchIfNeeded' implicitly has type 'any'` — circular type dependency, missing explicit handler return type annotation |

**Reasoning:** The GAPS.txt for this eval explicitly documents "Struggling with the return type on handler to break type cycles" as a known issue. When an action calls `ctx.runQuery(internal.index.getFetchResult, ...)` and `getFetchResult` is defined in the same file, TypeScript creates a circular type dependency. The model used `returns` validators (good practice) but didn't add an explicit `: Promise<...>` return type annotation on the `handler` function, which is needed to break the cycle. Many models struggle with this.

**Model output:**
```typescript
export const fetchIfNeeded = action({
  args: { url: v.string() },
  returns: v.id("fetchRequests"),
  handler: async (ctx, args) => {  // no return type annotation
    const existingId = await ctx.runQuery(internal.index.getFetchResult, { url: args.url });
    // ...
  },
});
```

**Expected:**
```typescript
export const fetchIfNeeded = action({
  args: { url: v.string() },
  handler: async (ctx, args): Promise<Id<"fetchRequests">> => {  // explicit annotation
    const existing = await ctx.runQuery(internal.index.getFetchResult, { url: args.url });
    // ...
  },
});
```

---

### 6. 006-clients/001-use_mutation — tsc failed

| Field | Value |
|-------|-------|
| **Classification** | MODEL_FAULT |
| **Failed step** | tsc |
| **Error** | `Unknown compiler option 'unusedLocals'` + project reference errors in `tsconfig.json` |

**Reasoning:** The model generated a `tsconfig.json` with an invalid compiler option `unusedLocals` (the correct option is `noUnusedLocals`) and used TypeScript project references pointing to `convex/tsconfig.json` which lacks `composite: true` and has `noEmit: true` — violating project reference requirements. The reference answer uses a simple `tsconfig.json` without project references. These are basic TypeScript configuration errors. Additionally, the model's mutation returns `v.id("messages")` instead of `v.null()` (a secondary issue documented in GAPS.txt).

**Model output (tsconfig.json):**
```json
{
  "compilerOptions": {
    "unusedLocals": false,  // invalid — should be "noUnusedLocals"
    // ...
  },
  "references": [{ "path": "./convex/tsconfig.json" }]  // requires composite: true
}
```

**Expected:**
```json
{
  "compilerOptions": {
    "strict": true,
    "moduleResolution": "Node",
    // ...
  },
  "include": ["src"]
}
```

---

### 7. 006-clients/002-use_paginated_query — tsc failed

| Field | Value |
|-------|-------|
| **Classification** | KNOWN_GAP |
| **Failed step** | tsc |
| **Error** | `TS2554: Expected 3 arguments, but got 2` — model merged query args and pagination options into a single argument |

**Reasoning:** The GAPS.txt explicitly documents that models struggle with the `usePaginatedQuery` hook: "Neither knows what to do with the `usePaginatedQuery` hook." The Convex `usePaginatedQuery` API requires 3 arguments `(queryRef, args, options)`, but the model conflated the second and third arguments, passing `{ initialNumItems: 5 }` as the query args instead of as the options with `{}` for the empty args.

**Model output:**
```typescript
const { results, status, loadMore } = usePaginatedQuery(
    api.items.paginateItems,
    { initialNumItems: 5 },  // wrong: should be 3rd arg
);
```

**Expected:**
```typescript
const { results, isLoading, loadMore, status } = usePaginatedQuery(
    api.items.paginateItems,
    {},                        // query args (empty)
    { initialNumItems: 10 },   // pagination options
);
```

---

## Cross-cutting Patterns

### 1. TypeScript Type Cycle Issues (3 failures)
Three failures (009-returns_validator, 006-no_storage, 002-run_query_mutation) involve TypeScript type inference / circular dependency issues. The model struggles with:
- Using `as const` for discriminated union return types
- Using `internal.*` instead of `api.*` to avoid circular type dependencies
- Adding explicit return type annotations on handlers to break type inference cycles

This is a significant pattern — Gemini 3 Pro understands the Convex API well enough to produce functionally correct code, but misses TypeScript-specific narrowing techniques.

### 2. Incomplete Convex API Knowledge (2 failures)
Two failures (018-pagination_returns_validator, 002-use_paginated_query) show incomplete knowledge of Convex-specific APIs:
- Missing `splitCursor` and `pageStatus` in pagination result validators
- Incorrect `usePaginatedQuery` call signature (2 args instead of 3)

### 3. TSConfig Misconfiguration (1 failure)
One failure (001-use_mutation) was caused by a broken `tsconfig.json` — an invalid compiler option and misconfigured project references. This is a basic TypeScript configuration mistake.

### 4. Possible Grader Flakiness (1 failure)
The 003-crons failure appears to be a grader issue rather than a model fault — the model's code was functionally identical to the reference answer.

## Recommendations

### Eval improvements
- **003-crons:** Investigate the grader's cron label detection. The string-matching against serialized `_cron_jobs` system table output may be fragile. Consider testing cron configuration via a more reliable mechanism, or mark as a known flaky eval.

### No action needed (genuine model faults)
- **009-returns_validator:** MODEL_FAULT — model should use `as const` for discriminated unions
- **018-pagination_returns_validator:** MODEL_FAULT — model should know full `PaginationResult` shape
- **006-no_storage:** MODEL_FAULT — model should use `internalMutation` + `internal.*` to avoid type cycles
- **001-use_mutation:** MODEL_FAULT — model generated invalid `tsconfig.json`

### Known gaps (already documented)
- **002-run_query_mutation:** KNOWN_GAP — handler return type annotation to break type cycles
- **002-use_paginated_query:** KNOWN_GAP — `usePaginatedQuery` 3-argument signature

## Net Impact Assessment

| Classification | Count | Evals |
|---------------|-------|-------|
| MODEL_FAULT | 4 | 009-returns_validator, 018-pagination_returns_validator, 006-no_storage, 001-use_mutation |
| KNOWN_GAP | 2 | 002-run_query_mutation, 002-use_paginated_query |
| OVERLY_STRICT | 1 | 003-crons |

- **4 failures** are genuine model faults — no action needed on eval side
- **2 failures** are known gaps already documented in GAPS.txt — models commonly struggle with these
- **1 failure** may warrant investigation into grader reliability (003-crons)
- **Adjusted pass rate** (excluding grader flakiness): 60/66 (90.9%)
