# Run Analysis: Qwen3.5 Plus — 2026-02-18

## Run Metadata

| Field | Value |
|-------|-------|
| Run ID | `jn78pe46wrs899sagdr2kds9w581dq2m` |
| Model | `qwen/qwen3.5-plus-02-15` |
| Formatted name | Qwen3.5 Plus |
| Experiment | default (with guidelines) |
| Date | 2026-02-18 |
| Pass rate | 49 / 66 (74.2%) |
| Duration | ~6.4 min |

## Failure Summary by Step Type

| Step | Count |
|------|-------|
| deploy (convex dev fail) | 9 |
| tsc | 3 |
| eslint | 3 |
| tests | 2 |
| **Total** | **17** |

---

## Per-Failure Analysis

### 000-fundamentals

#### 002-basic_http_endpoint — tsc
- **Classification:** MODEL_FAULT
- **Error:** `JSX element implicitly has type 'any' because no interface 'JSX.IntrinsicElements' exists`
- **Reasoning:** Model added `src/App.tsx` with JSX even though the task only requires Convex HTTP routes in `convex/`. No React types were present so tsc failed. The answer has no frontend.
- **Model output:**
```tsx
// src/App.tsx (should not exist)
export default function App() {
  return <div>HTTP Routes Backend Ready</div>;
}
```

#### 004-scheduler — eslint
- **Classification:** MODEL_FAULT
- **Error:** `@typescript-eslint/no-misused-promises` — async `onClick` handlers return Promise where void expected
- **Reasoning:** Model added `src/App.tsx` with `onClick={() => callerMutation()}` etc. The task is backend-only. The answer has no frontend.
- **Model output:**
```tsx
<button onClick={() => callerMutation()}>Run Scheduler Demo</button>
```

#### 005-function_calling — tsc
- **Classification:** MODEL_FAULT
- **Error:** Same as 002 — JSX without React types in unnecessary `src/App.tsx`
- **Reasoning:** Same pattern as 002: model added a frontend stub for a backend-only task.

#### 008-helper_fns — eslint
- **Classification:** MODEL_FAULT
- **Error:** `@typescript-eslint/no-explicit-any` + derived unsafe errors from `ctx: any`
- **Reasoning:** Model used `ctx: any` for the shared helper function's context parameter instead of `QueryCtx` / `MutationCtx`.
- **Model output:**
```ts
async function getItemData(ctx: any, itemId: Id<"items">) { ... }
```
- **Fix:** Use `QueryCtx` or the appropriate Convex context type.

#### 009-returns_validator — deploy
- **Classification:** MODEL_FAULT
- **Error:** TypeScript type error: `success: boolean` not assignable to `success: false` in discriminated union
- **Reasoning:** Model returned discriminated union objects without `as const`, so TypeScript inferred `success` as `boolean` rather than the literal types `true`/`false`.
- **Model output:**
```ts
return { success: false, error: "Post not found" };  // needs `as const`
return { success: true, post };                        // needs `as const`
```

---

### 002-queries

#### 011-denormalize_pagination — tests (17%)
- **Classification:** MODEL_FAULT
- **Error:** `ArgumentValidationError: Object is missing the required field 'paginationOpts'`
- **Reasoning:** Model used Convex's built-in `paginationOptsValidator` shape `{ paginationOpts }` instead of the flat `{ cursor, numItems }` args the task specifies.
- **Model output:**
```ts
args: { paginationOpts: paginationOptsValidator },
handler: async (ctx, args) => { ... paginate(args.paginationOpts) }
```
- **Expected:**
```ts
args: { cursor: v.union(v.string(), v.null()), numItems: v.number() },
handler: async (ctx, args) => { ... paginate({ cursor: args.cursor, numItems: args.numItems }) }
```

#### 014-select_distinct — eslint
- **Classification:** MODEL_FAULT
- **Error:** `prefer-const`, `no-unnecessary-type-assertion`, `await-thenable`
- **Reasoning:** Algorithm is correct but code quality issues: used `let` where `const` suffices, unnecessary `!` type assertions, and awaited non-Promises.

#### 021-intersection — tests (88%)
- **Classification:** MODEL_FAULT
- **Error:** Schema comparison failed — wrong index name
- **Reasoning:** Model named the index `"by_authorId_and_published"` instead of the required `"by_published"`.
- **Model output:**
```ts
.index("by_authorId_and_published", ["authorId", "published"])
```
- **Expected:**
```ts
.index("by_published", ["authorId", "published"])
```

---

### 003-mutations

#### 003-patch_nested — deploy
- **Classification:** KNOWN_GAP
- **Error:** TypeScript type error: `patch` with partial nested object replaces instead of merges
- **Reasoning:** GAPS.txt documents this: model doesn't know to spread existing nested object fields when patching. Used `{ metadata: { author: args.author } }` instead of `{ metadata: { ...document.metadata, author: args.author } }`.

#### 006-no_storage — deploy
- **Classification:** KNOWN_GAP
- **Error:** `Property 'store' does not exist on type 'StorageWriter'` — storage used in mutation
- **Reasoning:** GAPS.txt documents this: model implements `uploadFile` as a `mutation` but Convex storage is only available in actions.

---

### 004-actions

#### 001-run_mutation — deploy
- **Classification:** MODEL_FAULT
- **Error:** `saveFetchResult` is a mutation; only actions can be defined in Node.js
- **Reasoning:** Model unnecessarily added `"use node"` to the whole file, making mutations invalid. Also used `internal.*` for a public function (should use `api.*`).

#### 002-run_query_mutation — deploy
- **Classification:** MODEL_FAULT
- **Error:** TypeScript type cycle — `fetchIfNeeded` implicitly has type `any` because it references itself
- **Reasoning:** Model used `internal.*` to call public query/mutation functions (should use `api.*`), and omitted the explicit return type annotation needed to break the recursive type cycle.

#### 005-storage_http_action — deploy
- **Classification:** MODEL_FAULT
- **Error:** `Cannot find name 'process'` — `@types/node` missing
- **Reasoning:** Model used `process.env.CONVEX_SITE_URL` without adding `@types/node` to devDependencies.

#### 006-node — deploy
- **Classification:** MODEL_FAULT
- **Error:** `Cannot find module 'crypto' or its type declarations`
- **Reasoning:** Model correctly used `"use node"` and Node built-ins (`crypto`, `path`) but forgot to add `@types/node` devDependency.

#### 007-http_action_routing — deploy
- **Classification:** MODEL_FAULT
- **Error:** `No matching export 'httpRouter' from '_generated/server'`
- **Reasoning:** Model imported `httpRouter` from `"./_generated/server"` instead of `"convex/server"`. Also used `path: "/api/*"` glob pattern instead of `pathPrefix: "/api/"` (GAPS.txt documents this pathPrefix gap).

---

### 005-idioms

#### 002-batch_queries — deploy
- **Classification:** KNOWN_GAP
- **Error:** `Parameter 'q' implicitly has an 'any' type`
- **Reasoning:** GAPS.txt documents this: model used `ctx: any` for the helper function, causing the index query callback parameter `q` to also be inferred as `any` under strict mode.

---

### 006-clients

#### 001-use_mutation — tsc
- **Classification:** MODEL_FAULT
- **Error:** `Property 'isPending' does not exist on type 'ReactMutation<...>'`
- **Reasoning:** Model assumed a React Query–style API where `useMutation` returns an object with `isPending`. Convex's `useMutation` returns a callable function without that property. Correct approach uses `useState` for loading state.
- **Model output:**
```tsx
<button disabled={sendMessage.isPending}>
  {sendMessage.isPending ? "Sending..." : "Send Message"}
</button>
```
- **Expected:** Manual `useState(false)` for loading state.

---

## Cross-Cutting Patterns

### 1. Unnecessary frontend code (3 failures: 002, 004, 005 fundamentals)
The model consistently adds `src/App.tsx` for backend-only tasks. This is a systematic over-generation habit — the model assumes it should provide a complete full-stack demo even when the task is purely about Convex functions. Results in tsc or eslint failures from JSX/async-handler issues.

### 2. `ctx: any` usage (2 failures: 008-helper_fns, 002-batch_queries)
When writing shared helper functions, the model avoids typing the Convex context by using `any`. This is a gap in Convex-specific knowledge — the model doesn't know the correct context types (`QueryCtx`, `MutationCtx`, etc.).

### 3. Missing `@types/node` (2 failures: 005-storage_http_action, 006-node)
When using Node.js built-ins (`crypto`, `path`, `process`), the model correctly adds `"use node"` but forgets `@types/node` in devDependencies, causing tsc to fail at deploy.

### 4. `internal` vs `api` confusion (2 failures: 001-run_mutation, 002-run_query_mutation)
Model confuses `internal.*` (for functions marked `internalQuery`/`internalMutation`) with `api.*` (for public functions). Uses `internal.*` to call public functions, causing type or import errors.

### 5. Known Convex gaps (3 failures: 003-patch_nested, 006-no_storage, 002-batch_queries)
These are all documented in GAPS.txt: nested object patching requires spreading, storage is only available in actions, and context typing for shared helpers. These are recurring knowledge gaps the model consistently exhibits.

---

## Recommendations

### Eval improvements
- **None required** — no failures were classified as OVERLY_STRICT or AMBIGUOUS_TASK.

### Model-specific notes
- **Unnecessary frontend**: Model should not generate `src/App.tsx` unless the task explicitly asks for a frontend. This pattern caused 3 failures.
- **`ctx: any`**: Model should use `QueryCtx`/`MutationCtx` from `convex/server`. This is a recurring gap across multiple Qwen model variants.
- **`@types/node`**: Whenever `"use node"` is used or `process.env` is referenced, `@types/node` must be in devDependencies.
- **`internal` vs `api`**: `internal.*` is only for `internalQuery`/`internalMutation`; `api.*` is for public functions.
- **Convex API familiarity**: Several failures indicate the model hasn't deeply internalized Convex's API surface (e.g., `useMutation` return type, `pathPrefix` vs path globs, storage only in actions).

### No action needed
All 14 MODEL_FAULT failures are genuinely the model's fault. The 3 KNOWN_GAP failures match documented patterns.

---

## Net Impact Assessment

| Classification | Count | % |
|----------------|-------|---|
| MODEL_FAULT | 14 | 82% |
| KNOWN_GAP | 3 | 18% |
| OVERLY_STRICT | 0 | 0% |
| AMBIGUOUS_TASK | 0 | 0% |

**Verdict:** This is primarily poor model knowledge of the Convex API, not eval harshness. The model's 74% pass rate on the default experiment is respectable for a first baseline, but there are clear systematic gaps — especially around over-generating frontend code, incorrect context typing, and confusion about the `internal` vs `api` distinction. No changes to evals or lint config are warranted.
